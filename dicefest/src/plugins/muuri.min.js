/**
 * Muuri v0.6.3
 * https://github.com/haltu/muuri
 * Copyright (c) 2015-present, Haltu Oy
 * Released under the MIT license
 * https://github.com/haltu/muuri/blob/master/LICENSE.md
 * @license MIT
 *
 * Muuri Packer
 * Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>
 * @license MIT
 *
 * Muuri Ticker / Muuri Emitter / Muuri Queue
 * Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>
 * @license MIT
 */
!(function (t, i) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = i(require('hammerjs')) : typeof define === 'function' && define.amd ? define(['hammerjs'], i) : t.Muuri = i(t.Hammer) }(this, function (t) { 'use strict'; t = t && t.hasOwnProperty('default') ? t.default : t; const i = 'Muuri'; const e = {}; const s = 'layoutEnd'; function n () { this._events = {}, this._queue = [], this._processCount = 0, this._isDestroyed = !1 }n.prototype.on = function (t, i) { if (this._isDestroyed) return this; let e = this._events[t]; return e || (e = this._events[t] = []), e.push(i), this }, n.prototype.once = function (t, i) { if (this._isDestroyed) return this; var e = function () { this.off(t, e), i.apply(null, arguments) }.bind(this); return this.on(t, e) }, n.prototype.off = function (t, i) { if (this._isDestroyed) return this; const e = this._events[t]; if (!e || !e.length) return this; if (!i) return e.length = 0, this; for (let s = e.length; s--;)i === e[s] && e.splice(s, 1); return this }, n.prototype.emit = function (t, i, e, s) { if (this._isDestroyed) return this; const n = this._events[t]; if (!n || !n.length) return this; let r; let o; const h = this._queue; const a = h.length; const _ = arguments.length - 1; for (o = 0; o < n.length; o++)h.push(n[o]); for (r = h.length, ++this._processCount, o = a; o < r; o++) if (_ === 0 ? h[o]() : _ === 1 ? h[o](i) : _ === 2 ? h[o](i, e) : h[o](i, e, s), this._isDestroyed) return this; return --this._processCount, this._processCount || r !== h.length || (h.length = 0), this }, n.prototype.destroy = function () { if (this._isDestroyed) return this; let t; const i = this._events; for (t in this._isDestroyed = !0, this._queue.length = this._processCount = 0, i)i[t] && (i[t].length = 0, i[t] = void 0); return this }; let r = !1; let o = 'transform'; let h = 'transform'; ['', 'Webkit', 'Moz', 'O', 'ms'].forEach(function (t) { if (!r) { const i = t ? t + 'Transform' : 'transform'; void 0 !== document.documentElement.style[i] && (t = t.toLowerCase(), o = t ? '-' + t + '-transform' : 'transform', h = i, r = !0) } }); const a = typeof WeakMap === 'function' ? new WeakMap() : null; function _ (t, i) { let e = a && a.get(t); return e || (e = window.getComputedStyle(t, null), a && a.set(t, e)), e.getPropertyValue(i === 'transform' ? o : i) } function l (t, i) { const e = {}; for (const s in i)e[s] = _(t, s.replace(/([A-Z])/g, '-$1').toLowerCase()); return e } function d (t, i) { for (const e in i)t.style[e === 'transform' ? h : e] = i[e] } function f (t, i) { this._item = t, this._element = i, this._animation = null, this._propsTo = null, this._callback = null, this._keyframes = [], this._options = {}, this._isDestroyed = !1, this._onFinish = this._onFinish.bind(this) }f.prototype.start = function (t, i, e) { if (!this._isDestroyed) { let s; const n = e || 0; const r = typeof n.onFinish === 'function' ? n.onFinish : null; let o = !1; if (this._animation) { for (s in i) if (i[s] !== this._propsTo[s]) { o = !0; break } if (!o) return void (this._callback = r); this._animation.cancel() } for (s in this._callback = r, this._propsTo = {}, i) this._propsTo[s] = i[s]; this._keyframes[0] = t, this._keyframes[1] = i, this._options.duration = n.duration || 300, this._options.easing = n.easing || 'ease', this._animation = this._element.animate(this._keyframes, this._options), this._animation.onfinish = this._onFinish, d(this._element, i) } }, f.prototype.stop = function (t) { !this._isDestroyed && this._animation && (d(this._element, t || l(this._element, this._propsTo)), this._animation.cancel(), this._animation = this._propsTo = this._callback = null) }, f.prototype.isAnimating = function () { return !!this._animation }, f.prototype.destroy = function () { this._isDestroyed || (this.stop(), this._item = this._element = this._options = this._keyframes = null, this._isDestroyed = !0) }, f.prototype._onFinish = function () { const t = this._callback; this._animation = this._propsTo = this._callback = null, t && t() }; const u = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 16) }).bind(window); function c () { this._nextTick = null, this._queue = [], this._reads = {}, this._writes = {}, this._batch = [], this._batchReads = {}, this._batchWrites = {}, this._flush = this._flush.bind(this) }c.prototype.add = function (t, i, e, s) { const n = this._queue.indexOf(t); n > -1 && (this._queue[n] = void 0), s ? this._queue.unshift(t) : this._queue.push(t), this._reads[t] = i, this._writes[t] = e, this._nextTick || (this._nextTick = u(this._flush)) }, c.prototype.cancel = function (t) { const i = this._queue.indexOf(t); i > -1 && (this._queue[i] = void 0, this._reads[t] = void 0, this._writes[t] = void 0) }, c.prototype._flush = function () { let t; let i; const e = this._queue; const s = this._reads; const n = this._writes; const r = this._batch; const o = this._batchReads; const h = this._batchWrites; const a = e.length; for (this._nextTick = null, i = 0; i < a; i++)(t = e[i]) && (r.push(t), o[t] = s[t], s[t] = void 0, h[t] = n[t], n[t] = void 0); for (e.length = 0, i = 0; i < a; i++)o[t = r[i]] && (o[t](), o[t] = void 0); for (i = 0; i < a; i++)h[t = r[i]] && (h[t](), h[t] = void 0); r.length = 0, !this._nextTick && e.length && (this._nextTick = u(this._flush)) }; const p = new c(); const m = Element.prototype; const g = m.matches || m.matchesSelector || m.webkitMatchesSelector || m.mozMatchesSelector || m.msMatchesSelector || m.oMatchesSelector; function y (t, i) { return g.call(t, i) } const v = 'classList' in Element.prototype ? function (t, i) { t.classList.add(i) } : function (t, i) { y(t, '.' + i) || (t.className += ' ' + i) }; function w (t, i, e) { const s = t.length; const n = Math.max(0, e ? s : s - 1); return i > n ? n : i < 0 ? Math.max(n + i + 1, 0) : i } function D (t, i, e) { if (!(t.length < 2)) { const s = w(t, i); const n = w(t, e); s !== n && t.splice(n, 0, t.splice(s, 1)[0]) } } function b (t, i, e) { if (!(t.length < 2)) { let s; const n = w(t, i); const r = w(t, e); n !== r && (s = t[n], t[n] = t[r], t[r] = s) } } const S = 'cancel'; const A = 'finish'; function C (t, i) { let e; return i > 0 ? function (s) { void 0 !== e && (e = window.clearTimeout(e), s === A && t()), s !== S && s !== A && (e = window.setTimeout(function () { e = void 0, t() }, i)) } : function (i) { i !== S && t() } } function x (t) { const i = _(t, 'transform'); if (!i || i === 'none') return !1; const e = _(t, 'display'); return e !== 'inline' && e !== 'none' } function R (t, i) { for (var e = (i ? t : t.parentElement) || document; e && e !== document && _(e, 'position') === 'static' && !x(e);)e = e.parentElement || document; return e } function I (t, i) { return parseFloat(_(t, i)) || 0 } const L = {}; const E = {}; const M = {}; function H (t, i) { let e; const s = i || {}; return s.left = 0, s.top = 0, t === document ? s : (s.left = window.pageXOffset || 0, s.top = window.pageYOffset || 0, t.self === window.self ? s : (e = t.getBoundingClientRect(), s.left += e.left, s.top += e.top, s.left += I(t, 'border-left-width'), s.top += I(t, 'border-top-width'), s)) } function G (t, i, e) { return M.left = 0, M.top = 0, t === i ? M : e && (t = R(t, !0)) === (i = R(i, !0)) ? M : (H(t, L), H(i, E), M.left = E.left - L.left, M.top = E.top - L.top, M) } const T = {}; function P (t) { T.x = 0, T.y = 0; const i = _(t, 'transform'); if (!i) return T; const e = i.replace('matrix(', '').split(','); return T.x = parseFloat(e[4]) || 0, T.y = parseFloat(e[5]) || 0, T } function k (t, i) { return 'translateX(' + t + 'px) translateY(' + i + 'px)' } const O = []; function X (t, i, e) { let s = typeof e === 'number' ? e : -1; s < 0 && (s = t.length - s + 1), t.splice.apply(t, O.concat(s, 0, i)), O.length = 0 } const Y = '[object Object]'; const q = Object.prototype.toString; function B (t) { return typeof t === 'object' && q.call(t) === Y } const N = 'classList' in Element.prototype ? function (t, i) { t.classList.remove(i) } : function (t, i) { y(t, '.' + i) && (t.className = (' ' + t.className + ' ').replace(' ' + i + ' ', ' ').trim()) }; let F = Q(); const z = 0; const V = 1; const W = 2; const j = 3; function U (e) { if (!t) throw new Error('[' + i + '] required dependency Hammer is not defined.'); F === null && (F = Q()); let s; let n; const r = this; const o = e._element; const h = e.getGrid(); const a = h._settings; const _ = typeof a.dragStartPredicate === 'function' ? a.dragStartPredicate : U.defaultStartPredicate; let l = z; this._item = e, this._gridId = h._id, this._hammer = s = new t.Manager(o), this._isDestroyed = !1, this._isMigrating = !1, this._reset(), this._onScroll = this._onScroll.bind(this), this._prepareMove = this._prepareMove.bind(this), this._applyMove = this._applyMove.bind(this), this._prepareScroll = this._prepareScroll.bind(this), this._applyScroll = this._applyScroll.bind(this), this._checkOverlap = this._checkOverlap.bind(this), this._forceResolveStartPredicate = function (t) { this._isDestroyed || l !== V || (l = W, this._onStart(t)) }, this._checkOverlapDebounce = C(this._checkOverlap, a.dragSortInterval), s.add(new t.Pan({ event: 'drag', pointers: 1, threshold: 0, direction: t.DIRECTION_ALL })), s.add(new t.Press({ event: 'draginit', pointers: 1, threshold: 1e3, time: 0 })), B(a.dragHammerSettings) && s.set(a.dragHammerSettings), s.on('draginit dragstart dragmove', function (t) { l === z && (l = V), l === V ? !0 === (n = _(r._item, t)) ? (l = W, r._onStart(t)) : !1 === n && (l = j) : l === W && r._isActive && r._onMove(t) }).on('dragend dragcancel draginitup', function (t) { const i = l === W; _(r._item, t), l = z, i && r._isActive && r._onEnd(t) }), o.addEventListener('dragstart', Z, !1) } function Z (t) { t.preventDefault && t.preventDefault() } function $ (t, i) { return t.left + t.width <= i.left || i.left + i.width <= t.left || t.top + t.height <= i.top || i.top + i.height <= t.top ? 0 : (Math.min(t.left + t.width, i.left + i.width) - Math.max(t.left, i.left)) * (Math.min(t.top + t.height, i.top + i.height) - Math.max(t.top, i.top)) / (Math.min(t.width, i.width) * Math.min(t.height, i.height)) * 100 } function J (t, i) { const e = i || []; let s = t.parentNode; if (F) { if (_(t, 'position') === 'fixed') return e; for (;s && s !== document && s !== document.documentElement;)K(s) && e.push(s), s = _(s, 'position') === 'fixed' ? null : s.parentNode; return s !== null && e.push(window), e } for (;s && s !== document;)_(t, 'position') !== 'fixed' || x(s) ? (K(s) && e.push(s), t = s, s = s.parentNode) : s = s.parentNode; return e[e.length - 1] === document.documentElement ? e[e.length - 1] = window : e.push(window), e } function K (t) { let i = _(t, 'overflow'); return i === 'auto' || i === 'scroll' || ((i = _(t, 'overflow-x')) === 'auto' || i === 'scroll' || ((i = _(t, 'overflow-y')) === 'auto' || i === 'scroll')) } function Q () { if (!r) return !0; if (!document.body) return null; const t = [0, 1].map(function (t, i) { return (t = document.createElement('div')).style.position = i ? 'fixed' : 'absolute', t.style.display = 'block', t.style.visibility = 'hidden', t.style.left = i ? '0px' : '1px', t.style[h] = 'none', t }); const i = document.body.appendChild(t[0]); const e = i.appendChild(t[1]); const s = e.getBoundingClientRect().left; i.style[h] = 'scale(1)'; const n = s === e.getBoundingClientRect().left; return document.body.removeChild(i), n } function tt () { this._queue = [], this._isDestroyed = !1 } function it (t) { this._item = t, this._isActive = !1, this._isDestroyed = !1, this._isInterrupted = !1, this._currentStyles = {}, this._targetStyles = {}, this._currentLeft = 0, this._currentTop = 0, this._offsetLeft = 0, this._offsetTop = 0, this._skipNextAnimation = !1, this._animateOptions = { onFinish: this._finish.bind(this) }, this._queue = new tt(), this._setupAnimation = this._setupAnimation.bind(this), this._startAnimation = this._startAnimation.bind(this) }U.defaultStartPredicate = function (t, i, e) { const s = t._drag; const n = s._startPredicateData || s._setupStartPredicate(e); if (!i.isFinal) return !(!n.handleElement && (n.handleElement = s._getStartPredicateHandle(i), !n.handleElement)) && (n.delay && (n.event = i, n.delayTimer || (n.delayTimer = window.setTimeout(function () { n.delay = 0, s._resolveStartPredicate(n.event) && (s._forceResolveStartPredicate(n.event), s._resetStartPredicate()) }, n.delay))), s._resolveStartPredicate(i)); s._finishStartPredicate(i) }, U.defaultSortPredicate = (function () { const t = {}; const i = {}; const e = {}; const s = []; return function (n, r) { const o = n._drag; const h = o._getGrid(); const a = r && typeof r.threshold === 'number' ? r.threshold : 50; const _ = r && r.action === 'swap' ? 'swap' : 'move'; t.width = n._width, t.height = n._height, t.left = o._elementClientX, t.top = o._elementClientY; const l = (function (e, n, r) { let o; let h; let a; let _; let l = null; const d = n._settings.dragSort; let f = -1; if (!0 === d ? (s[0] = n, h = s) : h = d.call(n, e), !Array.isArray(h)) return l; for (_ = 0; _ < h.length; _++)(a = h[_])._isDestroyed || (a._updateBoundingRect(), i.width = a._width, i.height = a._height, i.left = a._left, i.top = a._top, (o = $(t, i)) > r && o > f && (f = o, l = a)); return s.length = 0, l }(n, h, a)); if (!l) return !1; let d; let f; let u; let c; let p; let m = 0; let g = 0; let y = -1; for (l === h ? (t.left = o._gridX + n._marginLeft, t.top = o._gridY + n._marginTop) : (l._updateBorders(1, 0, 1, 0), m = l._left + l._borderLeft, g = l._top + l._borderTop), p = 0; p < l._items.length; p++)(u = l._items[p])._isActive && u !== n && (f = !0, i.width = u._width, i.height = u._height, i.left = u._left + u._marginLeft + m, i.top = u._top + u._marginTop + g, (c = $(t, i)) > y && (d = p, y = c)); return y < a && n.getGrid() !== l && (d = f ? -1 : 0, y = 1 / 0), y >= a && (e.grid = l, e.index = d, e.action = _, e) } }()), U.prototype.stop = function () { const t = this._item._element; const i = this._getGrid(); return this._isActive ? this._isMigrating ? (this._finishMigration(), this) : (this._cancelAsyncUpdates(), this._unbindScrollListeners(), this._checkOverlapDebounce('cancel'), t.parentNode !== i._element && (i._element.appendChild(t), t.style[h] = k(this._gridX, this._gridY)), N(t, i._settings.itemDraggingClass), this._reset(), this) : this }, U.prototype.destroy = function () { return this._isDestroyed ? this : (this.stop(), this._hammer.destroy(), this._item._element.removeEventListener('dragstart', Z, !1), this._isDestroyed = !0, this) }, U.prototype._getGrid = function () { return e[this._gridId] || null }, U.prototype._reset = function () { this._isActive = !1, this._container = null, this._containingBlock = null, this._lastEvent = null, this._lastScrollEvent = null, this._scrollers = [], this._left = 0, this._top = 0, this._gridX = 0, this._gridY = 0, this._elementClientX = 0, this._elementClientY = 0, this._containerDiffX = 0, this._containerDiffY = 0 }, U.prototype._bindScrollListeners = function () { let t; let i; const e = this._getGrid()._element; const s = this._container; const n = this._scrollers; if (n.length = 0, J(this._item._element, n), s !== e) for (J(e, t = []), t.push(e), i = 0; i < t.length; i++)n.indexOf(t[i]) < 0 && n.push(t[i]); for (i = 0; i < n.length; i++)n[i].addEventListener('scroll', this._onScroll) }, U.prototype._unbindScrollListeners = function () { let t; const i = this._scrollers; for (t = 0; t < i.length; t++)i[t].removeEventListener('scroll', this._onScroll); i.length = 0 }, U.prototype._setupStartPredicate = function (t) { const i = t || this._getGrid()._settings.dragStartPredicate || 0; return this._startPredicateData = { distance: Math.abs(i.distance) || 0, delay: Math.max(i.delay, 0) || 0, handle: typeof i.handle === 'string' && i.handle } }, U.prototype._getStartPredicateHandle = function (t) { const i = this._startPredicateData; const e = this._item._element; let s = e; if (!i.handle) return s; for (s = (t.changedPointers[0] || 0).target; s && !y(s, i.handle);)s = s !== e ? s.parentElement : null; return s || null }, U.prototype._resolveStartPredicate = function (t) { let i; let e; let s; let n; let r; const o = this._startPredicateData; const h = t.changedPointers[0]; const a = h && h.pageX || 0; const _ = h && h.pageY || 0; if (!(t.distance < o.distance || o.delay)) return e = (i = o.handleElement.getBoundingClientRect()).left + (window.pageXOffset || 0), s = i.top + (window.pageYOffset || 0), n = i.width, r = i.height, this._resetStartPredicate(), n && r && a >= e && a < e + n && _ >= s && _ < s + r }, U.prototype._finishStartPredicate = function (t) { const i = this._item._element; this._resetStartPredicate(), (function (t) { return Math.abs(t.deltaX) < 2 && Math.abs(t.deltaY) < 2 && t.deltaTime < 200 }(t)) && (function (t) { if (t.tagName.toLowerCase() !== 'a') return; const i = t.getAttribute('href'); if (!i) return; const e = t.getAttribute('target'); e && e !== '_self' ? window.open(i, e) : window.location.href = i }(i)) }, U.prototype._resetStartPredicate = function () { const t = this._startPredicateData; t && (t.delayTimer && (t.delayTimer = window.clearTimeout(t.delayTimer)), this._startPredicateData = null) }, U.prototype._checkOverlap = function () { if (this._isActive) { let t; let i; let e; let s; let n; let r; let o; const h = this._item; const a = this._getGrid()._settings; (t = typeof a.dragSortPredicate === 'function' ? a.dragSortPredicate(h, this._lastEvent) : U.defaultSortPredicate(h, a.dragSortPredicate)) && typeof t.index === 'number' && (o = (i = h.getGrid()) !== (s = t.grid || i), e = i._items.indexOf(h), n = w(s._items, t.index, o), r = t.action === 'swap' ? 'swap' : 'move', o ? (i._hasListeners('beforeSend') && i._emit('beforeSend', { item: h, fromGrid: i, fromIndex: e, toGrid: s, toIndex: n }), s._hasListeners('beforeReceive') && s._emit('beforeReceive', { item: h, fromGrid: i, fromIndex: e, toGrid: s, toIndex: n }), h._gridId = s._id, this._isMigrating = h._gridId !== this._gridId, i._items.splice(e, 1), X(s._items, h, n), h._sortData = null, i._hasListeners('send') && i._emit('send', { item: h, fromGrid: i, fromIndex: e, toGrid: s, toIndex: n }), s._hasListeners('receive') && s._emit('receive', { item: h, fromGrid: i, fromIndex: e, toGrid: s, toIndex: n }), i.layout(), s.layout()) : e !== n && ((r === 'swap' ? b : D)(i._items, e, n), i._hasListeners('move') && i._emit('move', { item: h, fromIndex: e, toIndex: n, action: r }), i.layout())) } }, U.prototype._finishMigration = function () { let t; let i; const e = this._item; const s = e._release; const n = e._element; const r = e._isActive; const o = e.getGrid(); const a = o._element; const _ = o._settings; const l = _.dragContainer || a; const f = this._getGrid()._settings; const u = n.parentNode; this._isMigrating = !1, this.destroy(), N(n, f.itemClass), N(n, f.itemVisibleClass), N(n, f.itemHiddenClass), v(n, _.itemClass), v(n, r ? _.itemVisibleClass : _.itemHiddenClass), l !== u && (l.appendChild(n), i = G(u, l, !0), (t = P(n)).x -= i.left, t.y -= i.top), e._refreshDimensions(), e._refreshSortData(), i = G(l, a, !0), s._containerDiffX = i.left, s._containerDiffY = i.top, e._drag = _.dragEnabled ? new U(e) : null, l !== u && (n.style[h] = k(t.x, t.y)), e._child.removeAttribute('style'), d(e._child, r ? _.visibleStyles : _.hiddenStyles), s.start() }, U.prototype._cancelAsyncUpdates = function () { const t = this._item._id; p.cancel(t + 'move'), p.cancel(t + 'scroll') }, U.prototype._onStart = function (t) { const i = this._item; if (i._isActive) { let e; const s = i._element; const n = this._getGrid(); const r = n._settings; const o = i._release; const a = i._migrate; const _ = n._element; const l = r.dragContainer || _; const d = R(l, !0); const f = P(s); let u = f.x; let c = f.y; const p = s.getBoundingClientRect(); const m = l !== _; m && (e = G(d, _)), i.isPositioning() && i._layout.stop(!0, { transform: k(u, c) }), a._isActive && (u -= a._containerDiffX, c -= a._containerDiffY, a.stop(!0, { transform: k(u, c) })), i.isReleasing() && o._reset(), this._isActive = !0, this._lastEvent = t, this._container = l, this._containingBlock = d, this._elementClientX = p.left, this._elementClientY = p.top, this._left = this._gridX = u, this._top = this._gridY = c, n._emit('dragInit', i, t), m && (this._containerDiffX = e.left, this._containerDiffY = e.top, s.parentNode === l ? (this._gridX = u - this._containerDiffX, this._gridY = c - this._containerDiffY) : (this._left = u + this._containerDiffX, this._top = c + this._containerDiffY, l.appendChild(s), s.style[h] = k(this._left, this._top))), v(s, r.itemDraggingClass), this._bindScrollListeners(), n._emit('dragStart', i, t) } }, U.prototype._onMove = function (t) { const i = this._item; if (i._isActive) { const e = this._getGrid()._settings.dragAxis; const s = t.deltaX - this._lastEvent.deltaX; const n = t.deltaY - this._lastEvent.deltaY; this._lastEvent = t, e !== 'y' && (this._left += s, this._gridX += s, this._elementClientX += s), e !== 'x' && (this._top += n, this._gridY += n, this._elementClientY += n), p.add(i._id + 'move', this._prepareMove, this._applyMove, !0) } else this.stop() }, U.prototype._prepareMove = function () { this._item._isActive && this._getGrid()._settings.dragSort && this._checkOverlapDebounce() }, U.prototype._applyMove = function () { const t = this._item; t._isActive && (t._element.style[h] = k(this._left, this._top), this._getGrid()._emit('dragMove', t, this._lastEvent)) }, U.prototype._onScroll = function (t) { const i = this._item; i._isActive ? (this._lastScrollEvent = t, p.add(i._id + 'scroll', this._prepareScroll, this._applyScroll, !0)) : this.stop() }, U.prototype._prepareScroll = function () { const t = this._item; if (t._isActive) { let i; const e = t._element; const s = this._getGrid(); const n = s._settings; const r = n.dragAxis; const o = s._element; const h = e.getBoundingClientRect(); const a = this._elementClientX - h.left; const _ = this._elementClientY - h.top; this._container !== o && (i = G(this._containingBlock, o), this._containerDiffX = i.left, this._containerDiffY = i.top), r !== 'y' && (this._left += a, this._gridX = this._left - this._containerDiffX), r !== 'x' && (this._top += _, this._gridY = this._top - this._containerDiffY), n.dragSort && this._checkOverlapDebounce() } }, U.prototype._applyScroll = function () { const t = this._item; t._isActive && (t._element.style[h] = k(this._left, this._top), this._getGrid()._emit('dragScroll', t, this._lastScrollEvent)) }, U.prototype._onEnd = function (t) { const i = this._item; const e = i._element; const s = this._getGrid(); const n = s._settings; const r = i._release; i._isActive ? (this._cancelAsyncUpdates(), n.dragSort && this._checkOverlapDebounce('finish'), this._unbindScrollListeners(), r._containerDiffX = this._containerDiffX, r._containerDiffY = this._containerDiffY, this._reset(), N(e, n.itemDraggingClass), s._emit('dragEnd', i, t), this._isMigrating ? this._finishMigration() : r.start()) : this.stop() }, tt.prototype.add = function (t) { return this._isDestroyed ? this : (this._queue.push(t), this) }, tt.prototype.flush = function (t, i) { if (this._isDestroyed) return this; let e; const s = this._queue; const n = s.length; if (!n) return this; const r = n === 1; const o = r ? s[0] : s.slice(0); if (s.length = 0, r) return o(t, i), this; for (e = 0; e < n && (o[e](t, i), !this._isDestroyed); e++);return this }, tt.prototype.destroy = function () { return this._isDestroyed ? this : (this._isDestroyed = !0, this._queue.length = 0, this) }, it.prototype.start = function (t, i) { if (!this._isDestroyed) { let e; let s; let n; const r = this._item; const o = r._element; const h = r._migrate; const a = r._release; const _ = r.getGrid()._settings; const l = this._isActive; const f = a._isActive && !1 === a._isPositioningStarted; const u = f ? _.dragReleaseDuration : _.layoutDuration; const c = f ? _.dragReleaseEasing : _.layoutEasing; const m = !t && !this._skipNextAnimation && u > 0; return l && this._queue.flush(!0, r), f && (a._isPositioningStarted = !0), typeof i === 'function' && this._queue.add(i), e = a._isActive ? a._containerDiffX : h._isActive ? h._containerDiffX : 0, s = a._isActive ? a._containerDiffY : h._isActive ? h._containerDiffY : 0, this._targetStyles.transform = k(r._left + e, r._top + s), m ? (this._isActive = !0, this._animateOptions.easing = c, this._animateOptions.duration = u, this._isInterrupted = l, this._offsetLeft = e, this._offsetTop = s, p.add(r._id, this._setupAnimation, this._startAnimation), this) : (l && p.cancel(r._id), n = r._animate.isAnimating(), this.stop(!1, this._targetStyles), !n && d(o, this._targetStyles), this._skipNextAnimation = !1, this._finish()) } }, it.prototype.stop = function (t, i) { if (this._isDestroyed || !this._isActive) return this; const e = this._item; return p.cancel(e._id), e._animate.stop(i), N(e._element, e.getGrid()._settings.itemPositioningClass), this._isActive = !1, t && this._queue.flush(!0, e), this }, it.prototype.destroy = function () { return this._isDestroyed ? this : (this.stop(!0, {}), this._queue.destroy(), this._item = this._currentStyles = this._targetStyles = this._animateOptions = null, this._isDestroyed = !0, this) }, it.prototype._finish = function () { if (!this._isDestroyed) { const t = this._item; const i = t._migrate; const e = t._release; this._isActive && (this._isActive = !1, N(t._element, t.getGrid()._settings.itemPositioningClass)), e._isActive && e.stop(), i._isActive && i.stop(), this._queue.flush(!1, t) } }, it.prototype._setupAnimation = function () { const t = P(this._item._element); this._currentLeft = t.x - this._offsetLeft, this._currentTop = t.y - this._offsetTop }, it.prototype._startAnimation = function () { const t = this._item; const i = t._element; const e = t.getGrid()._settings; if (t._left === this._currentLeft && t._top === this._currentTop) return this._isInterrupted && this.stop(!1, this._targetStyles), this._isActive = !1, void this._finish(); !this._isInterrupted && v(i, e.itemPositioningClass), this._currentStyles.transform = k(this._currentLeft + this._offsetLeft, this._currentTop + this._offsetTop), t._animate.start(this._currentStyles, this._targetStyles, this._animateOptions) }; const et = {}; function st (t) { this._item = t, this._isActive = !1, this._isDestroyed = !1, this._container = !1, this._containerDiffX = 0, this._containerDiffY = 0 }st.prototype.start = function (t, i, e) { if (this._isDestroyed) return this; let s; let n; let r; let o; let a; let _; let l; let f; const u = this._item; const c = u._element; const p = u.isVisible(); const m = u.getGrid(); const g = m._settings; const y = t._settings; const D = t._element; const b = t._items; const S = m._items.indexOf(u); const A = e || document.body; if (typeof i === 'number')s = w(b, i, !0); else { if (!(n = t._getItem(i))) return this; s = b.indexOf(n) } return (u.isPositioning() || this._isActive || u.isReleasing()) && (l = (_ = P(c)).x, f = _.y), u.isPositioning() && u._layout.stop(!0, { transform: k(l, f) }), this._isActive && (l -= this._containerDiffX, f -= this._containerDiffY, this.stop(!0, { transform: k(l, f) })), u.isReleasing() && (l -= u._release._containerDiffX, f -= u._release._containerDiffY, u._release.stop(!0, { transform: k(l, f) })), u._visibility._stopAnimation(), u._drag && u._drag.destroy(), u._visibility._queue.flush(!0, u), m._hasListeners('beforeSend') && m._emit('beforeSend', { item: u, fromGrid: m, fromIndex: S, toGrid: t, toIndex: s }), t._hasListeners('beforeReceive') && t._emit('beforeReceive', { item: u, fromGrid: m, fromIndex: S, toGrid: t, toIndex: s }), N(c, g.itemClass), N(c, g.itemVisibleClass), N(c, g.itemHiddenClass), v(c, y.itemClass), v(c, p ? y.itemVisibleClass : y.itemHiddenClass), m._items.splice(S, 1), X(b, u, s), u._gridId = t._id, A !== (r = c.parentNode) && (A.appendChild(c), o = G(A, r, !0), _ || (l = (_ = P(c)).x, f = _.y), c.style[h] = k(l + o.left, f + o.top)), u._child.removeAttribute('style'), d(u._child, p ? y.visibleStyles : y.hiddenStyles), c.style.display = p ? 'block' : 'hidden', a = G(A, D, !0), u._refreshDimensions(), u._refreshSortData(), u._drag = y.dragEnabled ? new U(u) : null, this._isActive = !0, this._container = A, this._containerDiffX = a.left, this._containerDiffY = a.top, m._hasListeners('send') && m._emit('send', { item: u, fromGrid: m, fromIndex: S, toGrid: t, toIndex: s }), t._hasListeners('receive') && t._emit('receive', { item: u, fromGrid: m, fromIndex: S, toGrid: t, toIndex: s }), this }, st.prototype.stop = function (t, i) { if (this._isDestroyed || !this._isActive) return this; let e; const s = this._item; const n = s._element; const r = s.getGrid()._element; return this._container !== r && (i || (t ? (e = P(n), et.transform = k(e.x - this._containerDiffX, e.y - this._containerDiffY)) : et.transform = k(s._left, s._top), i = et), r.appendChild(n), d(n, i)), this._isActive = !1, this._container = null, this._containerDiffX = 0, this._containerDiffY = 0, this }, st.prototype.destroy = function () { return this._isDestroyed ? this : (this.stop(!0), this._item = null, this._isDestroyed = !0, this) }; const nt = {}; function rt (t) { this._item = t, this._isActive = !1, this._isDestroyed = !1, this._isPositioningStarted = !1, this._containerDiffX = 0, this._containerDiffY = 0 } function ot (t) { const i = t._isActive; const e = t._element; const s = t.getGrid()._settings; this._item = t, this._isDestroyed = !1, this._isHidden = !i, this._isHiding = !1, this._isShowing = !1, this._queue = new tt(), this._finishShow = this._finishShow.bind(this), this._finishHide = this._finishHide.bind(this), e.style.display = i ? 'block' : 'none', v(e, i ? s.itemVisibleClass : s.itemHiddenClass), d(t._child, i ? s.visibleStyles : s.hiddenStyles) }rt.prototype.start = function () { if (this._isDestroyed || this._isActive) return this; const t = this._item; const i = t.getGrid(); return this._isActive = !0, v(t._element, i._settings.itemReleasingClass), i._emit('dragReleaseStart', t), t._layout.start(!1), this }, rt.prototype.stop = function (t, i) { if (this._isDestroyed || !this._isActive) return this; let e; const s = this._item; const n = s._element; const r = s.getGrid(); const o = r._element; return this._reset(), n.parentNode !== o && (i || (t ? (e = P(n), nt.transform = k(e.x - this._containerDiffX, e.y - this._containerDiffY)) : nt.transform = k(s._left, s._top), i = nt), o.appendChild(n), d(n, i)), t || r._emit('dragReleaseEnd', s), this }, rt.prototype.destroy = function () { return this._isDestroyed ? this : (this.stop(!0), this._item = null, this._isDestroyed = !0, this) }, rt.prototype._reset = function () { if (!this._isDestroyed) { const t = this._item; this._isActive = !1, this._isPositioningStarted = !1, this._containerDiffX = 0, this._containerDiffY = 0, N(t._element, t.getGrid()._settings.itemReleasingClass) } }, ot.prototype.show = function (t, i) { if (this._isDestroyed) return this; const e = this._item; const s = e._element; const n = this._queue; const r = typeof i === 'function' ? i : null; const o = e.getGrid()._settings; return this._isShowing || this._isHidden ? this._isShowing && !t ? (r && n.add(r), this) : (this._isShowing || (n.flush(!0, e), N(s, o.itemHiddenClass), v(s, o.itemVisibleClass), this._isHiding || (s.style.display = 'block')), r && n.add(r), e._isActive = this._isShowing = !0, this._isHiding = this._isHidden = !1, this._startAnimation(!0, t, this._finishShow), this) : (r && r(!1, e), this) }, ot.prototype.hide = function (t, i) { if (this._isDestroyed) return this; const e = this._item; const s = e._element; const n = this._queue; const r = typeof i === 'function' ? i : null; const o = e.getGrid()._settings; return !this._isHiding && this._isHidden ? (r && r(!1, e), this) : this._isHiding && !t ? (r && n.add(r), this) : (this._isHiding || (n.flush(!0, e), v(s, o.itemHiddenClass), N(s, o.itemVisibleClass)), r && n.add(r), this._isHidden = this._isHiding = !0, e._isActive = this._isShowing = !1, this._startAnimation(!1, t, this._finishHide), this) }, ot.prototype.destroy = function () { if (this._isDestroyed) return this; const t = this._item; const i = t._element; const e = t.getGrid(); const s = this._queue; const n = e._settings; return this._stopAnimation({}), s.flush(!0, t).destroy(), N(i, n.itemVisibleClass), N(i, n.itemHiddenClass), this._item = null, this._isHiding = this._isShowing = !1, this._isDestroyed = this._isHidden = !0, this }, ot.prototype._startAnimation = function (t, i, e) { if (!this._isDestroyed) { let s; const n = this._item; const r = n.getGrid()._settings; const o = t ? r.visibleStyles : r.hiddenStyles; const h = parseInt(t ? r.showDuration : r.hideDuration) || 0; const a = (t ? r.showEasing : r.hideEasing) || 'ease'; const _ = i || h <= 0; if (o) { if (p.cancel(n._id + 'visibility'), _) return n._animateChild.isAnimating() ? n._animateChild.stop(o) : d(n._child, o), void (e && e()); p.add(n._id + 'visibility', function () { s = l(n._child, o) }, function () { n._animateChild.start(s, o, { duration: h, easing: a, onFinish: e }) }) } else e && e() } }, ot.prototype._stopAnimation = function (t) { if (!this._isDestroyed) { const i = this._item; p.cancel(i._id), i._animateChild.stop(t) } }, ot.prototype._finishShow = function () { this._isHidden || (this._isShowing = !1, this._queue.flush(!1, this._item)) }; const ht = {}; ot.prototype._finishHide = function () { if (this._isHidden) { const t = this._item; this._isHiding = !1, ht.transform = k(0, 0), t._layout.stop(!0, ht), t._element.style.display = 'none', this._queue.flush(!1, t) } }; let at; let _t; let lt; let dt; let ft = 0; function ut () { return ++ft } function ct (t, i, e) { const s = t._settings; this._id = ut(), this._gridId = t._id, this._isDestroyed = !1, this._left = 0, this._top = 0, this._element = i, this._child = i.children[0], i.parentNode !== t._element && t._element.appendChild(i), v(i, s.itemClass), typeof e !== 'boolean' && (e = _(i, 'display') !== 'none'), this._isActive = e, i.style.left = '0', i.style.top = '0', i.style[h] = k(0, 0), this._animate = new f(this, i), this._animateChild = new f(this, this._child), this._visibility = new ot(this), this._layout = new it(this), this._migrate = new st(this), this._release = new rt(this), this._drag = s.dragEnabled ? new U(this) : null, this._refreshDimensions(), this._refreshSortData() } function pt () { this._layout = { slots: [], slotSizes: [], setWidth: !1, setHeight: !1, width: !1, height: !1 }, this._freeSlots = [], this._newSlots = [], this._rectItem = {}, this._rectStore = [], this._rectId = 0, this._sortRectsLeftTop = this._sortRectsLeftTop.bind(this), this._sortRectsTopLeft = this._sortRectsTopLeft.bind(this) }ct.prototype.getGrid = function () { return e[this._gridId] }, ct.prototype.getElement = function () { return this._element }, ct.prototype.getWidth = function () { return this._width }, ct.prototype.getHeight = function () { return this._height }, ct.prototype.getMargin = function () { return { left: this._marginLeft, right: this._marginRight, top: this._marginTop, bottom: this._marginBottom } }, ct.prototype.getPosition = function () { return { left: this._left, top: this._top } }, ct.prototype.isActive = function () { return this._isActive }, ct.prototype.isVisible = function () { return !!this._visibility && !this._visibility._isHidden }, ct.prototype.isShowing = function () { return !(!this._visibility || !this._visibility._isShowing) }, ct.prototype.isHiding = function () { return !(!this._visibility || !this._visibility._isHiding) }, ct.prototype.isPositioning = function () { return !(!this._layout || !this._layout._isActive) }, ct.prototype.isDragging = function () { return !(!this._drag || !this._drag._isActive) }, ct.prototype.isReleasing = function () { return !(!this._release || !this._release._isActive) }, ct.prototype.isDestroyed = function () { return this._isDestroyed }, ct.prototype._refreshDimensions = function () { if (!this._isDestroyed && !this._visibility._isHidden) { const t = this._element; const i = t.getBoundingClientRect(); this._width = i.width, this._height = i.height, this._marginLeft = Math.max(0, I(t, 'margin-left')), this._marginRight = Math.max(0, I(t, 'margin-right')), this._marginTop = Math.max(0, I(t, 'margin-top')), this._marginBottom = Math.max(0, I(t, 'margin-bottom')) } }, ct.prototype._refreshSortData = function () { if (!this._isDestroyed) { let t; const i = this._sortData = {}; const e = this.getGrid()._settings.sortData; for (t in e)i[t] = e[t](this, this._element) } }, ct.prototype._destroy = function (t) { if (!this._isDestroyed) { const i = this._element; const e = this.getGrid(); const s = e._settings; const n = e._items.indexOf(this); this._release.destroy(), this._migrate.destroy(), this._layout.destroy(), this._visibility.destroy(), this._animate.destroy(), this._animateChild.destroy(), this._drag && this._drag.destroy(), i.removeAttribute('style'), this._child.removeAttribute('style'), N(i, s.itemClass), n > -1 && e._items.splice(n, 1), t && i.parentNode.removeChild(i), this._isActive = !1, this._isDestroyed = !0 } }, pt.prototype.getLayout = function (t, i, e, s) { let n; const r = this._layout; const o = !(!s || !s.fillGaps); const h = !(!s || !s.horizontal); const a = !(!s || !s.alignRight); const _ = !(!s || !s.alignBottom); const l = !(!s || !s.rounding); if (r.slots.length = r.slotSizes.length = 0, r.width = h ? 0 : l ? Math.round(i) : i, r.height = h ? l ? Math.round(e) : e : 0, r.setWidth = h, r.setHeight = !h, !t.length) return r; for (n = 0; n < t.length; n++) this._addSlot(t[n], h, o, l); if (a) for (n = 0; n < r.slots.length; n += 2)r.slots[n] = r.width - (r.slots[n] + r.slotSizes[n]); if (_) for (n = 1; n < r.slots.length; n += 2)r.slots[n] = r.height - (r.slots[n] + r.slotSizes[n]); return this._freeSlots.length = 0, this._newSlots.length = 0, this._rectId = 0, r }, pt.prototype._addSlot = (at = {}, function (t, i, e, s) { let n; let r; let o; let h; let a; let _; const l = this._layout; const d = this._freeSlots; const f = this._newSlots; for (f.length = 0, at.left = null, at.top = null, at.width = t._width + t._marginLeft + t._marginRight, at.height = t._height + t._marginTop + t._marginBottom, s && (at.width = Math.round(at.width), at.height = Math.round(at.height)), a = 0; a < d.length; a++) if ((r = d[a]) && (n = this._getRect(r), at.width <= n.width + 0.001 && at.height <= n.height + 0.001)) { at.left = n.left, at.top = n.top; break } for (at.left === null && (at.left = i ? l.width : 0, at.top = i ? 0 : l.height, e || (h = !0)), !i && at.top + at.height > l.height && (at.left > 0 && f.push(this._addRect(0, l.height, at.left, 1 / 0)), at.left + at.width < l.width && f.push(this._addRect(at.left + at.width, l.height, l.width - at.left - at.width, 1 / 0)), l.height = at.top + at.height), i && at.left + at.width > l.width && (at.top > 0 && f.push(this._addRect(l.width, 0, 1 / 0, at.top)), at.top + at.height < l.height && f.push(this._addRect(l.width, at.top + at.height, 1 / 0, l.height - at.top - at.height)), l.width = at.left + at.width), a = e ? 0 : h ? d.length : a; a < d.length; a++) if (r = d[a]) for (n = this._getRect(r), o = this._splitRect(n, at), _ = 0; _ < o.length; _++)r = o[_], (n = this._getRect(r)).width > 0.49 && n.height > 0.49 && (!i && n.top < l.height || i && n.left < l.width) && f.push(r); f.length && this._purgeRects(f).sort(i ? this._sortRectsLeftTop : this._sortRectsTopLeft), i ? l.width = Math.max(l.width, at.left + at.width) : l.height = Math.max(l.height, at.top + at.height), l.slots.push(at.left, at.top), l.slotSizes.push(at.width, at.height), this._freeSlots = f, this._newSlots = d }), pt.prototype._addRect = function (t, i, e, s) { const n = ++this._rectId; const r = this._rectStore; return r[n] = t || 0, r[++this._rectId] = i || 0, r[++this._rectId] = e || 0, r[++this._rectId] = s || 0, n }, pt.prototype._getRect = function (t, i) { const e = i || this._rectItem; const s = this._rectStore; return e.left = s[t] || 0, e.top = s[++t] || 0, e.width = s[++t] || 0, e.height = s[++t] || 0, e }, pt.prototype._splitRect = (_t = [], function (t, i) { return _t.length = 0, this._doRectsOverlap(t, i) ? (t.left < i.left && _t.push(this._addRect(t.left, t.top, i.left - t.left, t.height)), t.left + t.width > i.left + i.width && _t.push(this._addRect(i.left + i.width, t.top, t.left + t.width - (i.left + i.width), t.height)), t.top < i.top && _t.push(this._addRect(t.left, t.top, t.width, i.top - t.top)), t.top + t.height > i.top + i.height && _t.push(this._addRect(t.left, i.top + i.height, t.width, t.top + t.height - (i.top + i.height))), _t) : (_t.push(this._addRect(t.left, t.top, t.width, t.height)), _t) }), pt.prototype._doRectsOverlap = function (t, i) { return !(t.left + t.width <= i.left || i.left + i.width <= t.left || t.top + t.height <= i.top || i.top + i.height <= t.top) }, pt.prototype._isRectWithinRect = function (t, i) { return t.left >= i.left && t.top >= i.top && t.left + t.width <= i.left + i.width && t.top + t.height <= i.top + i.height }, pt.prototype._purgeRects = (lt = {}, dt = {}, function (t) { for (var i, e = t.length; e--;) if (i = t.length, t[e]) for (this._getRect(t[e], lt); i--;) if (t[i] && e !== i && this._isRectWithinRect(lt, this._getRect(t[i], dt))) { t[e] = 0; break } return t }), pt.prototype._sortRectsTopLeft = (function () { const t = {}; const i = {}; return function (e, s) { return this._getRect(e, t), this._getRect(s, i), t.top < i.top ? -1 : t.top > i.top ? 1 : t.left < i.left ? -1 : t.left > i.left ? 1 : 0 } }()), pt.prototype._sortRectsLeftTop = (function () { const t = {}; const i = {}; return function (e, s) { return this._getRect(e, t), this._getRect(s, i), t.left < i.left ? -1 : t.left > i.left ? 1 : t.top < i.top ? -1 : t.top > i.top ? 1 : 0 } }()); const mt = '[object HTMLCollection]'; const gt = '[object NodeList]'; function yt (t) { const i = Object.prototype.toString.call(t); return i === mt || i === gt } function vt (t) { return yt(t) ? Array.prototype.slice.call(t) : Array.prototype.concat(t) } const wt = new pt(); const Dt = function () {}; function bt (t, i) { let s; let r; let o; const h = this; if (t = this._element = typeof t === 'string' ? document.querySelector(t) : t, !document.body.contains(t)) throw new Error('Container element must be an existing DOM element'); typeof (s = this._settings = (function (t, i) { let e = St({}, t); i && (e = St(e, i)); return e.visibleStyles = (i || 0).visibleStyles || (t || 0).visibleStyles, e.hiddenStyles = (i || 0).hiddenStyles || (t || 0).hiddenStyles, e }(bt.defaultOptions, i))).dragSort !== 'function' && (s.dragSort = !!s.dragSort), this._id = ut(), e[this._id] = h, this._isDestroyed = !1, this._layout = { id: 0, items: [], slots: [], setWidth: !1, setHeight: !1, width: 0, height: 0 }, this._emitter = new n(), v(t, s.containerClass), this._items = [], typeof (r = s.items) === 'string' ? vt(t.children).forEach(function (t) { (r === '*' || y(t, r)) && h._items.push(new ct(h, t)) }) : (Array.isArray(r) || yt(r)) && (this._items = vt(r).map(function (t) { return new ct(h, t) })), typeof (o = s.layoutOnResize) !== 'number' && (o = !0 === o ? 0 : -1), o >= 0 && window.addEventListener('resize', h._resizeHandler = C(function () { h.refreshItems().layout() }, o)), s.layoutOnInit && this.layout(!0) } function St (t, i) { let e; let s; let n; const r = Object.keys(i); const o = r.length; for (n = 0; n < o; n++)e = B(i[s = r[n]]), B(t[s]) && e ? t[s] = St(St({}, t[s]), i[s]) : e ? t[s] = St({}, i[s]) : Array.isArray(i[s]) ? t[s] = i[s].slice(0) : t[s] = i[s]; return t } return bt.Item = ct, bt.ItemLayout = it, bt.ItemVisibility = ot, bt.ItemRelease = rt, bt.ItemMigrate = st, bt.ItemAnimate = f, bt.ItemDrag = U, bt.Emitter = n, bt.defaultOptions = { items: '*', showDuration: 300, showEasing: 'ease', hideDuration: 300, hideEasing: 'ease', visibleStyles: { opacity: '1', transform: 'scale(1)' }, hiddenStyles: { opacity: '0', transform: 'scale(0.5)' }, layout: { fillGaps: !1, horizontal: !1, alignRight: !1, alignBottom: !1, rounding: !0 }, layoutOnResize: 100, layoutOnInit: !0, layoutDuration: 300, layoutEasing: 'ease', sortData: null, dragEnabled: !1, dragContainer: null, dragStartPredicate: { distance: 0, delay: 0, handle: !1 }, dragAxis: null, dragSort: !0, dragSortInterval: 100, dragSortPredicate: { threshold: 50, action: 'move' }, dragReleaseDuration: 300, dragReleaseEasing: 'ease', dragHammerSettings: { touchAction: 'none' }, containerClass: 'muuri', itemClass: 'muuri-item', itemVisibleClass: 'muuri-item-shown', itemHiddenClass: 'muuri-item-hidden', itemPositioningClass: 'muuri-item-positioning', itemDraggingClass: 'muuri-item-dragging', itemReleasingClass: 'muuri-item-releasing' }, bt.prototype.on = function (t, i) { return this._emitter.on(t, i), this }, bt.prototype.once = function (t, i) { return this._emitter.once(t, i), this }, bt.prototype.off = function (t, i) { return this._emitter.off(t, i), this }, bt.prototype.getElement = function () { return this._element }, bt.prototype.getItems = function (t) { if (this._isDestroyed || !t && t !== 0) return this._items.slice(0); let i; let e; const s = []; const n = vt(t); for (e = 0; e < n.length; e++)(i = this._getItem(n[e])) && s.push(i); return s }, bt.prototype.refreshItems = function (t) { if (this._isDestroyed) return this; let i; const e = this.getItems(t); for (i = 0; i < e.length; i++)e[i]._refreshDimensions(); return this }, bt.prototype.refreshSortData = function (t) { if (this._isDestroyed) return this; let i; const e = this.getItems(t); for (i = 0; i < e.length; i++)e[i]._refreshSortData(); return this }, bt.prototype.synchronize = function () { if (this._isDestroyed) return this; let t; let i; let e; const s = this._element; const n = this._items; if (n.length) { for (e = 0; e < n.length; e++)(i = n[e]._element).parentNode === s && (t = t || document.createDocumentFragment()).appendChild(i); t && s.appendChild(t) } return this._emit('synchronize'), this }, bt.prototype.layout = function (t, i) { if (this._isDestroyed) return this; let e; let n; let r; const o = this; const h = this._element; const a = this._updateLayout(); const l = a.id; const d = a.items.length; let f = d; const u = typeof t === 'function' ? t : i; const c = typeof u === 'function'; const p = c ? a.items.slice(0) : null; function m () { if (!(--f > 0)) { const t = o._layout.id !== l; c && u(t, p), !t && o._hasListeners(s) && o._emit(s, a.items.slice(0)) } } if ((a.setHeight && typeof a.height === 'number' || a.setWidth && typeof a.width === 'number') && (e = _(h, 'box-sizing') === 'border-box'), a.setHeight && (typeof a.height === 'number' ? h.style.height = (e ? a.height + this._borderTop + this._borderBottom : a.height) + 'px' : h.style.height = a.height), a.setWidth && (typeof a.width === 'number' ? h.style.width = (e ? a.width + this._borderLeft + this._borderRight : a.width) + 'px' : h.style.width = a.width), this._hasListeners('layoutStart') && this._emit('layoutStart', a.items.slice(0)), !d) return m(), this; for (r = 0; r < d; r++)(n = a.items[r]) && (n._left = a.slots[2 * r], n._top = a.slots[2 * r + 1], n.isDragging() ? m() : n._layout.start(!0 === t, m)); return this }, bt.prototype.add = function (t, i) { if (this._isDestroyed || !t) return []; const e = vt(t); if (!e.length) return e; let s; let n; const r = i || 0; const o = r.layout ? r.layout : void 0 === r.layout; const h = this._items; let a = !1; for (n = 0; n < e.length; n++)s = new ct(this, e[n], r.isActive), e[n] = s, s._isActive && (a = !0, s._layout._skipNextAnimation = !0); return X(h, e, r.index), this._hasListeners('add') && this._emit('add', e.slice(0)), a && o && this.layout(o === 'instant', typeof o === 'function' ? o : void 0), e }, bt.prototype.remove = function (t, i) { if (this._isDestroyed) return this; let e; let s; const n = i || 0; const r = n.layout ? n.layout : void 0 === n.layout; let o = !1; const h = this.getItems(); const a = this.getItems(t); const _ = []; for (s = 0; s < a.length; s++)e = a[s], _.push(h.indexOf(e)), e._isActive && (o = !0), e._destroy(n.removeElements); return this._hasListeners('remove') && this._emit('remove', a.slice(0), _), o && r && this.layout(r === 'instant', typeof r === 'function' ? r : void 0), a }, bt.prototype.show = function (t, i) { return this._isDestroyed ? this : (this._setItemsVisibility(t, !0, i), this) }, bt.prototype.hide = function (t, i) { return this._isDestroyed ? this : (this._setItemsVisibility(t, !1, i), this) }, bt.prototype.filter = function (t, i) { if (this._isDestroyed || !this._items.length) return this; let e; let s; const n = []; const r = []; const o = typeof t === 'string'; const h = typeof t === 'function'; const a = i || 0; const _ = !0 === a.instant; const l = a.layout ? a.layout : void 0 === a.layout; const d = typeof a.onFinish === 'function' ? a.onFinish : null; let f = -1; let u = Dt; if (d && (u = function () { ++f && d(n.slice(0), r.slice(0)) }), h || o) for (s = 0; s < this._items.length; s++)e = this._items[s], (h ? t(e) : y(e._element, t)) ? n.push(e) : r.push(e); return n.length ? this.show(n, { instant: _, onFinish: u, layout: !1 }) : u(), r.length ? this.hide(r, { instant: _, onFinish: u, layout: !1 }) : u(), (n.length || r.length) && (this._hasListeners('filter') && this._emit('filter', n.slice(0), r.slice(0)), l && this.layout(l === 'instant', typeof l === 'function' ? l : void 0)), this }, bt.prototype.sort = (function () { let t, e, s, n; function r (t) { for (var i = {}, e = 0; e < t.length; e++)i[t[e]._id] = e; return i } function o (t, i) { const s = n[t._id]; const r = n[i._id]; return e ? r - s : s - r } function h (i, h) { for (var a, _, l, d, f = 0, u = 0; u < t.length; u++) if (a = t[u][0], _ = t[u][1], l = (i._sortData ? i : i._refreshSortData())._sortData[a], d = (h._sortData ? h : h._refreshSortData())._sortData[a], f = _ === 'desc' || !_ && e ? d < l ? -1 : d > l ? 1 : 0 : l < d ? -1 : l > d ? 1 : 0) return f; return f || (n || (n = r(s)), f = o(i, h)), f } function a (i, h) { let a = t(i, h); return e && a && (a = -a), a || (n || (n = r(s)), a = o(i, h)), a } return function (r, o) { if (this._isDestroyed || this._items.length < 2) return this; let _; const l = this._items; const d = o || 0; const f = d.layout ? d.layout : void 0 === d.layout; if (t = r, e = !!d.descending, s = l.slice(0), n = null, typeof t === 'function')l.sort(a); else if (typeof t === 'string')t = r.trim().split(' ').map(function (t) { return t.split(':') }), l.sort(h); else { if (!Array.isArray(t)) return this; if (t.length !== l.length) throw new Error('[' + i + '] sort reference items do not match with grid items.'); for (_ = 0; _ < l.length; _++) { if (t.indexOf(l[_]) < 0) throw new Error('[' + i + '] sort reference items do not match with grid items.'); l[_] = t[_] }e && l.reverse() } return this._hasListeners('sort') && this._emit('sort', l.slice(0), s), f && this.layout(f === 'instant', typeof f === 'function' ? f : void 0), this } }()), bt.prototype.move = function (t, i, e) { if (this._isDestroyed || this._items.length < 2) return this; let s; let n; const r = this._items; const o = e || 0; const h = o.layout ? o.layout : void 0 === o.layout; const a = o.action === 'swap'; const _ = a ? 'swap' : 'move'; const l = this._getItem(t); const d = this._getItem(i); return l && d && l !== d && (s = r.indexOf(l), n = r.indexOf(d), a ? b(r, s, n) : D(r, s, n), this._hasListeners('move') && this._emit('move', { item: l, fromIndex: s, toIndex: n, action: _ }), h && this.layout(h === 'instant', typeof h === 'function' ? h : void 0)), this }, bt.prototype.send = function (t, i, e, s) { if (this._isDestroyed || i._isDestroyed || this === i) return this; if (!(t = this._getItem(t))) return this; const n = s || 0; const r = n.appendTo || document.body; const o = n.layoutSender ? n.layoutSender : void 0 === n.layoutSender; const h = n.layoutReceiver ? n.layoutReceiver : void 0 === n.layoutReceiver; return t._migrate.start(i, e, r), t._migrate._isActive && t._isActive && (o && this.layout(o === 'instant', typeof o === 'function' ? o : void 0), h && i.layout(h === 'instant', typeof h === 'function' ? h : void 0)), this }, bt.prototype.destroy = function (t) { if (this._isDestroyed) return this; let i; const s = this._element; const n = this._items.slice(0); for (this._resizeHandler && window.removeEventListener('resize', this._resizeHandler), i = 0; i < n.length; i++)n[i]._destroy(t); return N(s, this._settings.containerClass), s.style.height = '', s.style.width = '', this._emit('destroy'), this._emitter.destroy(), e[this._id] = void 0, this._isDestroyed = !0, this }, bt.prototype._getItem = function (t) { if (this._isDestroyed || !t && t !== 0) return null; if (typeof t === 'number') return this._items[t > -1 ? t : this._items.length + t] || null; if (t instanceof ct) return t._gridId === this._id ? t : null; for (let i = 0; i < this._items.length; i++) if (this._items[i]._element === t) return this._items[i]; return null }, bt.prototype._updateLayout = function () { let t; const i = this._layout; const e = this._settings.layout; for (++i.id, i.items.length = 0, t = 0; t < this._items.length; t++) this._items[t]._isActive && i.items.push(this._items[t]); this._refreshDimensions(); const s = this._width - this._borderLeft - this._borderRight; const n = this._height - this._borderTop - this._borderBottom; const r = typeof e === 'function' ? e(i.items.slice(0), s, n) : wt.getLayout(i.items, s, n, e); return i.slots = r.slots.slice(0), i.setWidth = Boolean(r.setWidth), i.setHeight = Boolean(r.setHeight), i.width = r.width, i.height = r.height, i }, bt.prototype._emit = function () { this._isDestroyed || this._emitter.emit.apply(this._emitter, arguments) }, bt.prototype._hasListeners = function (t) { const i = this._emitter._events[t]; return !(!i || !i.length) }, bt.prototype._updateBoundingRect = function () { const t = this._element.getBoundingClientRect(); this._width = t.width, this._height = t.height, this._left = t.left, this._top = t.top }, bt.prototype._updateBorders = function (t, i, e, s) { const n = this._element; t && (this._borderLeft = I(n, 'border-left-width')), i && (this._borderRight = I(n, 'border-right-width')), e && (this._borderTop = I(n, 'border-top-width')), s && (this._borderBottom = I(n, 'border-bottom-width')) }, bt.prototype._refreshDimensions = function () { this._updateBoundingRect(), this._updateBorders(1, 1, 1, 1) }, bt.prototype._setItemsVisibility = function (t, i, e) { let s; let n; const r = this; const o = this.getItems(t); const h = e || 0; const a = !0 === h.instant; const _ = h.onFinish; const l = h.layout ? h.layout : void 0 === h.layout; let d = o.length; const f = i ? 'showStart' : 'hideStart'; const u = i ? 'showEnd' : 'hideEnd'; const c = i ? 'show' : 'hide'; let p = !1; const m = []; const g = []; if (d) { for (this._hasListeners(f) && this._emit(f, o.slice(0)), n = 0; n < o.length; n++)s = o[n], (i && !s._isActive || !i && s._isActive) && (p = !0), i && !s._isActive && (s._layout._skipNextAnimation = !0), i && s._visibility._isHidden && g.push(s), s._visibility[c](a, function (t, i) { t || m.push(i), --d < 1 && (typeof _ === 'function' && _(m.slice(0)), r._hasListeners(u) && r._emit(u, m.slice(0))) }); g.length && this.refreshItems(g), p && l && this.layout(l === 'instant', typeof l === 'function' ? l : void 0) } else typeof _ === 'function' && _(o) }, bt }))
